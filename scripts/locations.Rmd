---
title: "Locations AMR"
author: "Emma Mendelsohn"
date: "9/19/2018"
output:
      html_document:
        keep_md: true
---
Setup
```{r setup, include=TRUE, echo=TRUE, eval=FALSE}
library(tidyverse)
library(magrittr)
library(stringi)
library(sf)
library(mapview)
library(opencage)
library(googlesheets)
#gs_auth(new_user = TRUE)

#Function for data manipulation
paste_collapse <- function(x){
  x <- x[!is.na(x) & x!=""]
  paste(x, collapse = ", ")
}

wd <- gsub("scripts", "data", getwd())
load(paste0(wd, "/coded_annotations.RData")) #data compiled in 03_clean_segments.r
field_corrections <- gs_read(gs_title("amr_db_field_corrections")) %>% as.tibble() #google spreadsheet tracking field corrections
sub_names <- gs_read(gs_title("amr_db_clean_locs")) %>% as.tibble() #google spreadsheet with field cleanup

```
Fix to mislabeled locations 
```{r, include=TRUE, echo=TRUE, eval=FALSE}
field_corrections %<>%
  mutate(study_id=as.character(study_id)) %>%
  filter(requires_followup=="No") %>%
  select(-requires_followup, -notes)
codes %<>%
  left_join(.,field_corrections) %>%
  mutate(code_main = ifelse(is.na(code_main_new), code_main, code_main_new)) %>%
  select(-code_main_new)
```
Manual Subsitutions
```{r, include=TRUE, echo=TRUE, eval=FALSE}
sub_names2 <- tribble( #not handled well by google spreadsheet
  ~old,                    ~new,
  "\r\n",                  "",
  "- ",                    "",
  ",",                     "",
  "2",                     ""
)
sub_names <- bind_rows(sub_names2, sub_names) #combine with google doc

city_names  <- tribble( #add countries to cities missing country or state
  ~City,             ~Country,
  "toronto",         "canada",
  "rio de janeiro",  "brazil",
  "santo domingo",   "dominican republic",
  "calgary",         "canada",
  "liverpool",       "united kingdom",
  "rome",            "italy"
)

state_names  <- tribble( #add countries to cities missing country or state
  ~"State/Province/District",  ~Country,
  "california",         "united states",
  "kanto",              "japan",
  "georgia",            "united states",
  "new york",           "united states"
)

```
Clean data
```{r, include=TRUE, echo=TRUE, eval=FALSE}
dat <- codes %>% #reshape and clean names
  filter(code_main_cat=="Location") %>%
  spread(key = code_main, value = segment) %>%
  select(-matches_str) %>%
  unique() %>%
  group_by(code_main_cat, study_id, code_identifiers) %>%
  summarise_all(funs(paste_collapse)) %>%
  rename("Hospital"= `Hospital name`) %>%
  mutate_all(funs(tolower)) %>%
  mutate_at(vars(Country, City, Hospital, `State/Province/District`), funs(stri_replace_all_regex(.,  sub_names$old, sub_names$new, vectorize_all = FALSE))) %>%
  mutate_all(funs(trimws(., "both"))) %>%
  ungroup() 

dat <- left_join(dat, city_names, by="City") %>% #assign countried to cities and states without countries
  mutate(Country= ifelse(is.na(Country.y), Country.x, Country.y)) %>%
  select(-Country.y, -Country.x) %>%
  left_join(., state_names, by="State/Province/District") %>%
  mutate(Country= ifelse(is.na(Country.y), Country.x, Country.y)) %>%
  select(-Country.y, -Country.x) 

```
Evaluate data available
```{r, include=TRUE, echo=TRUE, eval=FALSE}
pref <- c( #Order from most preferable to least
  "Hospital_City_Country",
  "Hospital_City_State/Province/District",
  "Hospital_State/Province/District_Country",
  "Hospital_City",
  "Hospital_State/Province/District",
  "Hospital_Country",
  "Hospital",
  "City_Country", 
  "City_State/Province/District", 
  "State/Province/District_Country", 
  "City", 
  "State/Province/District", 
  "Country") #TODO"Place traveled to" 

dat <- as.data.frame(dat)
dat$geoloc_basis <- ""
dat$geoloc_value <- ""

#based on above preference order, assign basis for geocode (geoloc_basis) and extract location name (geoloc_value)
for (i in rev(seq_along(pref))){
  cnames <- strsplit(pref[i], "_") %>% unlist
  dat_avail <- apply(dat[,c("study_id", cnames)]!="", 1, all) #if all relevant columns have values
  dat$geoloc_basis <- ifelse(dat_avail, 
                             pref[i], 
                             dat$geoloc_basis)
  if(length(cnames)>1){
    dat$geoloc_value <- ifelse(dat_avail, 
                               apply(dat[, c(cnames)], 1 , paste, collapse = ", "),
                               dat$geoloc_value)
  }else{
    dat$geoloc_value <- ifelse(dat_avail, 
                               dat[, c(cnames)],
                               dat$geoloc_value)
  }
}

```

```{r, include=FALSE}
#testing
# hosp <- unique(dat$geoloc_value[grepl("Hospital", dat$geoloc_basis)])
# 
# for (i in 1:length(hosp)){
#   out <- opencage_forward( hosp[i], limit = 1)
#   lat <- out$results$geometry.lat
#   lon <- out$results$geometry.lng
#   stopifnot(lat%%1!=0)
# }
```
Geocode function for batch processing in opencage
```{r}
opencage_forward_mutate <- function(data, location){
  
  #TODO test for NA in location
  
  locs <- data[, location, drop = TRUE] #extract location
  
  out <- map(locs, opencage::opencage_forward, limit=1) #map opencage_forward function to locations
  
  #TODO - find better way to iterate list
  gcdf <- data.frame() 
  for(i in seq_along(out)){
    tmp <- data.frame(lat = out[[i]]$results$geometry.lat,
                      lon = out[[i]]$results$geometry.lng)
    if(nrow(tmp)==0){stop()}
    gcdf <- rbind(gcdf, tmp)
  }
  cbind(data, gcdf)
}
```
Geocode
```{r}
cdat <- dat %>%
  filter(geoloc_basis!="") %>% #follow up on these (place traveled to is only field)
  filter(!geoloc_value%in%c("i.r.c.c.s. “s. matteo” “casa sollievo della sofferenza” hospital) i.r.c.c.s. “s. maugeri”, italy", #tmp until issue 15289 resolved
         "air force general hospital pla", #where is this? - NEED TO ADD TO FIX FEATURE LIST
         "cf centre of the paediatric department of dijon's hospital: the crcm (centre de ressources et de compétences pour la mucoviscidose), dijon, france")) %>% #ESM to follow up
  opencage_forward_mutate(location = "geoloc_value")

cdat_sf <- st_as_sf(cdat, coords = c("lon", "lat"), crs = 4326)
mapview(cdat_sf, zcol="geoloc_basis", col.regions = colorRampPalette(RColorBrewer::brewer.pal(7, "Set1")), alpha.regions=1)

```

Notes
```{r}
dat %>% group_by(geoloc_basis) %>% summarize(n=n())

dat[!is.na(dat$code_identifiers),]

#TODO Continue troubleshooling hospital names 
#TODO include location participant traveled to (addition to geoloc_value)
#TODO include residence (addition to geoloc_value)
#TODO handle locations with A, B etc identifiers

```
