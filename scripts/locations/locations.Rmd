---
title: "Locations AMR"
author: "Emma Mendelsohn"
date: "9/19/2018"
output:
      html_document:
        keep_md: true
---
Setup
```{r setup}
knitr::opts_chunk$set(include=TRUE, echo=FALSE, message=FALSE)

library(tidyverse)
library(magrittr)
library(stringi)
library(sf)
library(mapview)
library(opencage)
library(googlesheets)
library(here)
#gs_auth(new_user = TRUE)

#Function for data manipulation
paste_collapse <- function(x){
  x <- x[!is.na(x) & x!=""]
  paste(x, collapse = ", ")
}

#Geocode function for batch processing in opencage
##note: Opencage typically returns multiple results because of placename ambiguity - here we limit to 1 by default
opencage_forward_mutate <- function(data, location, limit=1){
  locs <- data[, location, drop = TRUE] #extract location
  out <- map(locs, opencage_forward, limit=limit) #map opencage_forward function to locations
  gcdf <- data.frame() #empty dataframe
  for(i in seq_along(out)){ #extract lat and long
    tmp <- data.frame(lat = out[[i]]$results$geometry.lat,
                      lon = out[[i]]$results$geometry.lng)
    if(nrow(tmp)==0){tmp <- data.frame(lat=NA, lon=NA)} #NA if no lat/long 
    gcdf <- rbind(gcdf, tmp)
  }
  cbind(data, gcdf)
}

load(here("data", "coded_annotations.RData")) #data compiled in 03_clean_segments.r
field_corrections <- gs_read(gs_title("amr_db_field_corrections")) %>% as.tibble() #google spreadsheet tracking field corrections
sub_names1 <- gs_read(gs_title("amr_db_clean_locs")) %>% as.tibble() #google spreadsheet with field cleanup
```
Fix to mislabeled locations 
```{r}
field_corrections %<>% 
  mutate(study_id=as.character(study_id)) %>%
  filter(requires_followup=="No") %>%
  select(-requires_followup, -notes)

codes %<>%
  left_join(.,field_corrections) %>%
  mutate(code_main = ifelse(is.na(code_main_new), code_main, code_main_new)) %>%
  select(-code_main_new) %>%
  filter(!study_id %in% unique(codes$study_id[codes$code_main_cat=="Exclusion"])) #remove excluded studies
```
Manual Subsitutions
```{r}
sub_names2 <- tribble( #these values are handled well by google spreadsheet 
  ~old,                    ~new,
  "\r\n",                  "",
  "- ",                    "",
  #",",                     "",
  "2",                     ""
)

sub_names <- bind_rows(sub_names2, sub_names1) #combine with google doc for complete correction list
                       
city_names  <- tribble( #add countries to cities missing country or state
  ~city,             ~country,
  "toronto",         "canada",
  "rio de janeiro",  "brazil",
  "santo domingo",   "dominican republic",
  "calgary",         "canada",
  "liverpool",       "united kingdom",
  "rome",            "italy"
)

state_names  <- tribble( #add countries to cities missing country or state
  ~"state/province/district",  ~country,
  "california",         "united states",
  "kanto",              "japan",
  "georgia",            "united states",
  "new york",           "united states"
)

```
Clean data
```{r}
#reshape  
dat <- codes %>%
  filter(code_main_cat=="Location"|code_main=="Country of Residence") %>%
  select(-code_main_cat) %>%
  spread(key = code_main, value = segment) %>%
  select(-matches_str) %>%
  unique() %>%
  group_by(study_id, code_identifiers) %>%
  summarise_all(funs(paste_collapse)) %>%
  ungroup()

#clean names
dat %<>%
  rename_all(tolower) %>%
  rename("hospital" = `hospital name`, "travel_location" = `place traveled to`, "residence_location" = `country of residence`) %>%
  mutate_all(funs(tolower)) %>%
  mutate_all(funs(gsub("\\(|\\)", "", .))) %>%
  mutate_at(vars(country, city, hospital, `state/province/district`, travel_location, residence_location), funs(stri_replace_all_regex(.,  sub_names$old, sub_names$new, vectorize_all = FALSE))) %>%
  mutate_all(funs(trimws(., "both"))) 

#assign countries to cities and states without countries
dat <- left_join(dat, city_names, by="city") %>% 
  mutate(country= ifelse(is.na(country.y), country.x, country.y)) %>%
  select(-country.y, -country.x) %>%
  left_join(., state_names, by="state/province/district") %>%
  mutate(country= ifelse(is.na(country.y), country.x, country.y)) %>%
  select(-country.y, -country.x) 

#split travel locations
do_not_split <- c("california, san francisco", "india, new delhi", "riyadh, saudi arabia", "new delhi, india", "mumbai, india", "karachi, pakistan", "cairo, egypt")

dat %<>%
  mutate(travel_location = ifelse(is.na(travel_location), "", travel_location)) %>%
  mutate(travel_location = ifelse(travel_location %in% do_not_split, travel_location, gsub("\\,", "\\;", travel_location))) %>%
  mutate(cat_split = str_split(travel_location, ";")) %>%
  unnest() %>%
  mutate(cat_split = str_trim(cat_split)) %>%
  select(-travel_location) %>%
  group_by(study_id) %>%
  mutate(travel_location_id = paste0("loc_", row_number())) %>%
  rename(travel_location = cat_split) %>%
  ungroup() #%>%
  #opencage_forward_mutate(location = "travel_location") %>%
  #rename(travel_lat = lat, travel_lon=lon)

```
Evaluate data available for study locations
```{r}
pref <- c( #Order from most preferable to least
  "hospital_city_country",
  "hospital_city_state/province/district",
  "hospital_state/province/district_country",
  "hospital_city",
  "hospital_state/province/district",
  "hospital_country",
  "hospital",
  "city_country", 
  "city_state/province/district", 
  "state/province/district_country", 
  "city", 
  "state/province/district", 
  "country")  

dat <- as.data.frame(dat)
dat$study_location_basis <- ""
dat$study_location <- ""

#based on above preference order, assign basis for geocode (study_location_basis) and extract location name (study_location)
for (i in rev(seq_along(pref))){
  cnames <- strsplit(pref[i], "_") %>% unlist
  dat_avail <- apply(dat[,c("study_id", cnames)]!="", 1, all) #if all relevant columns have values
  dat$study_location_basis <- ifelse(dat_avail, 
                             pref[i], 
                             dat$study_location_basis)
  if(length(cnames)>1){
    dat$study_location <- ifelse(dat_avail, 
                               apply(dat[, c(cnames)], 1 , paste, collapse = ", "),
                               dat$study_location)
  }else{
    dat$study_location <- ifelse(dat_avail, 
                               dat[, c(cnames)],
                               dat$study_location)
  }
}

dat %<>% rename(study_country=country, study_city=city, study_hospital=hospital, `study_state/province/district`= `state/province/district`) %>%
  select(study_id, code_identifiers, study_hospital, study_city, `study_state/province/district`, study_country, 
         study_location_basis, study_location, travel_location, travel_location_id, residence_location)
```

Geocode
```{r}
dat %<>%
  opencage_forward_mutate(location = "study_location") %>%
  rename(study_location_lat = lat, study_location_lon=lon) %>%
  opencage_forward_mutate(location = "travel_location") %>%
  rename(travel_location_lat = lat, travel_location_lon=lon) %>%
  opencage_forward_mutate(location = "residence_location") %>%
  rename(residence_location_lat = lat, residence_location_lon=lon) 

```

Maps
```{r}
mapviewOptions(legend.pos="bottomleft")

dat_sf_loc <- st_as_sf(dat %>% filter(!is.na(study_location_lat)) %>% unique(), coords = c("study_location_lon", "study_location_lat"), crs = 4326)
mapview(dat_sf_loc, zcol="study_location_basis", col.regions = colorRampPalette(RColorBrewer::brewer.pal(9, "Set1")), alpha.regions=1, layer.name="Study Location Spatial Resolution")

dat_sf_trav <- st_as_sf(dat %>% filter(!is.na(travel_location_lat)), coords = c("travel_location_lon", "travel_location_lat"), crs = 4326)
mapview(dat_sf_trav, col.regions = colorRampPalette(RColorBrewer::brewer.pal(9, "Set1")), alpha.regions=1, layer.name = "Travel Locations")

dat_sf_res <- st_as_sf(dat %>% filter(!is.na(residence_location_lat)) %>% unique, coords = c("residence_location_lon", "residence_location_lat"), crs = 4326)
mapview(dat_sf_res, col.regions = colorRampPalette(RColorBrewer::brewer.pal(9, "Set1")), alpha.regions=1, layer.name = "Residence Locations")
```

Notes
```{r}
#For QA:
write.csv(dat, "location_coords.csv",row.names = F)

#STUDIES THAT HAVE CODE IDENTIFIERS
dat[!is.na(dat$code_identifiers),]

#HOW MANY STUDIES DO NOT HAVE LOCS
codes %>% 
  group_by(study_id) %>% 
  summarize(segs = paste(unique(code_main_cat), collapse=", ")) %>%
  filter(!grepl("Location", segs)) %>%
  ungroup() %>% nrow()

#RESIDENCE
codes %>%
  filter(code_main=="Country of Residence")

#TODO include residence (addition to study_location)
#TODO handle locations with A, B etc identifiers

```
